#include <stdio.h>
#include <stdlib.h>
#include <math.h>
//
#define ITER_MAX 50
//evaporation rate
#define p  0.5
//influence rate of the pheroneme
#define alpha 0.6
//influence rate of the heuristic (distance)
#define beta 0.4
//Initial level of pheroneme
#define C 0.5
//Pheroneme constant
#define Q 5 

void init_graph(int * G, int size)
{
    int i,j;
    for(i=0 ; i<size ; i++)
    {
        for(j=0 ; j<size ; j++)
        {
            if(i==j)
                G[size*i + j] = 0;
            else{
            G[size*i + j] = 1;}
        }
    }
}

//function that initialize the pheroneme to a constant value
void init_pheroneme(float * T, int size)
{
    int i,j;
    for(i=0 ; i<size ; i++)
    {
        for(j=0 ; j<size ; j++)
        {
            T[size*i + j] = C;
        }
    }
}

void update_pheroneme(float * T, int size)
{
    int i,j;
    for(i=0 ; i<size ; i++)
    {
        for(j=0 ; j<size ; j++)
        {
    	    //evaporation
            T[size*i + j] = (1-p) * T[size*i + j];
	    //update based on constructed solutions
        }
    }
}

void update_prob(int * G, float * T, float * P, int size, float sum)
{
    int i,j;
    for(i=0 ; i<size ; i++)
    {
        for(j=0 ; j<size ; j++)
        {
            int index = size*i + j;
            P[index] = pow(T[index],alpha) * pow(1/G[index],beta)/sum;
        }
    }
}

float sum_prob(int * G, float * T, int size)
{
    int i,j;
    float sum = 0;
    for(i=0 ; i<size ; i++)
    {
        for(j=0 ; j<size ; j++)
        {
            int index = size*i + j;
            sum += pow(T[index],alpha) * pow(1/G[index],beta);
        }
    }
    return sum;
}

int main()
{
    //Let's denote n the number of nodes
    //and N the size of the problem
    int n = 5;
    int N = n*n;
    //We define the graph using a matrix of size N
    //This matrix contain the distance between each node 
    //if two nodes are not connected then the value is -1 
    int * G = malloc(sizeof(int)*N);

    //We define the level of pheroneme for each edge in a matrix
    float * T = malloc(sizeof(float)*N);

    //We define the matrice of the probabilities
    float * P = malloc(sizeof(float)*N);

    //Initialize the graph and the level of pheroneme
    init_graph(G,n);
    init_pheroneme(T,n);
    
    //Initialize the probabilities
    float sum = sum_prob(G,T,n);
    update_prob(G,T,P,n,sum);

    //Let's define the number of ants that are going to go through the graph
    int nb_ants = 10;

    //Array that contain the length of the path generated by each ant 
    int * L = malloc(sizeof(int)*nb_ants);

    //number of iteration
    int iter = 0;
    
    //Minimum length
    int Lmin;

    //Shortest path
    int * Pmin;
    
    while(iter<ITER_MAX)
    {
        //for each ant construct a path from the starting point to the final point
        int k;
        for(k=0 ; k<nb_ants ; k++)
        {
		int i;
		//initialize the array that contain the solution
		int * kth_solution = malloc(sizeof(int)*n);
		for(i=0; i<n ; i++)
		{
			kth_solution[i]=0;
			
		}

		//Generate the solution
		i=1;
		while(kth_solution[i] != n)
		{
			//select the next node based on the probability
			i++;
		}

		//Calculate the length of the path
		L[k]=0;
		i=0;
		while(kth_solution[i] != n)
                {
                        L[k] += G[kth_solution[i]+kth_solution[i+1]*n];
			i++;
                }

        	//find the shortest length and path
           	Lmin=L[0];
                if(L[k]<=Lmin) 
		{
			Lmin = L[k];
			Pmin = kth_solution;
		}
                
		free(kth_solution);
                                                        
        }	

        //update pheroneme values
        update_pheroneme(T,n);

        //update probabilities
        sum = sum_prob(G,T,n);
        update_prob(G,T,P,n,sum);

        //increment iter
        iter++;
    }

    //Free the memory
    free(G);
    free(T);
    free(P);
    free(L);

    return 0;
}
